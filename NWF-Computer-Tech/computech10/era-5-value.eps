%!PS-Adobe-3.0 EPSF-3.0
%%BoundingBox: 52 70 404 219
%%Creator:       Tom Browder
%%CreationDate:  2010-01-21
%%Title:         VALUE Model of ERA [5]
%%+              file: era-value-5.eps
%%LanguageLevel: 2
[
%
/mydict 300 dict def
mydict begin
% definitions:
/mt {moveto} bind def
/lto {lineto} bind def
/np {newpath} bind def
/cp {closepath} bind def
/rl {rlineto} bind def
/rm {rmoveto} bind def
/tr {translate} bind def
/st {stroke} bind def
/rot {rotate} bind def
/sl {setlinewidth} bind def
/gs {gsave} bind def
/gr {grestore} bind def
/p2i {72 div} bind def           % convert points to inches
/i2p {72 mul} bind def           % convert inches to points
/mm2p {25.4 div 72 mul} bind def % convert millimeters to points
/a2p {60 div 72 mul} bind def    % convert ASI units (60ths of an inch) to points
/ft2pt 1 def % value normally generated by brldraw; default is 1
% various constants:
/lw1 {1.5 setlinewidth} bind def % main line width (in points)
/lw2 {.75 setlinewidth} bind def % dimension and label line width (in points)
/lengthxyz {20} def % nominal length of a coordinate arrow
/textspace {6} def % space between text and any other object
/ticlen {5} def % length of major tic mark on a scale
/ang_width {.4 72 mul} bind def
/ang_diag {ang_width 45 cos div} bind def
/ds 5 def  % space between point to be dimensioned and the 'hash' mark
/dh 20 def % length of has mark to dimension line
/dt 5 def  % extra hash line 'above' hash mark
/xtra ang_diag ang_width sub 45 cos mul def
end % mydict

/puttext { % string location_code [integer: 0-11] (to place--relative to the current point); must have a current and correct font
  30 dict begin
  /code exch def
  /stname exch def
  gsave
  currentpoint translate np
  0 0 mt stname false charpath flattenpath pathbbox
  /ury exch def
  /urx exch def
  /lly exch def
  /llx exch def
  /mx urx llx add .5 mul def
  /my ury lly add .5 mul def

  0 code eq {/ox 0 mx  sub def /oy 0 my  sub def} if %               center of text bounding box positioned at the current point
  1 code eq {/ox 0 llx sub def /oy 0 my  sub def} if %  center of left edge of text bounding box positioned at the current point
  2 code eq {/ox 0 llx sub def /oy 0 lly sub def} if %    lower left corner of text bounding box positioned at the current point
  3 code eq {/ox 0 mx  sub def /oy 0 lly sub def} if % center of lower edge of text bounding box positioned at the current point
  4 code eq {/ox 0 urx sub def /oy 0 lly sub def} if %   lower right corner of text bounding box positioned at the current point
  5 code eq {/ox 0 urx sub def /oy 0 my  sub def} if % center of right edge of text bounding box positioned at the current point
  6 code eq {/ox 0 urx sub def /oy 0 ury sub def} if %   upper right corner of text bounding box positioned at the current point
  7 code eq {/ox 0 mx  sub def /oy 0 ury sub def} if % center of upper edge of text bounding box positioned at the current point
  8 code eq {/ox 0 llx sub def /oy 0 ury sub def} if %    upper left corner of text bounding box positioned at the current point

  9 code eq {/ox 0 llx sub def /oy 0         def} if % on base line (y of current point), left-justified on current point
 10 code eq {/ox 0 mx  sub def /oy 0         def} if % on base line (y of current point), centered horizontally
 11 code eq {/ox 0 urx sub def /oy 0         def} if % on base line (y of current point), right-justified on current point

  ox oy translate

  gsave
  % 0 setgray
  np 0 0 mt stname show
  grestore

%for debug
%  gsave
%  [3] 0 setdash
%  .1 setlinewidth np
%  llx lly mt urx lly lineto urx ury lineto llx ury lineto closepath stroke
%  grestore

  grestore
  end
} def % puttext

/label { % the stack contains: (label text) p1x p1y p2x p2y % first to last
  30 dict begin
  /p2y exch def
  /p2x exch def
  /p1y exch def
  /p1x exch def
  /labeltext exch def

  /deltax p2x p1x sub def
  /deltay p2y p1y sub def
  /labellength deltax deltax mul deltay deltay mul add sqrt def
  /labelang p2y p1y sub p2x p1x sub atan def

  gsave
  lw2
  p1x p1y moveto
  deltax abs deltax eq {-3 0 rm labeltext 5 puttext}{3 0 rm labeltext 1 puttext} ifelse
  p1x p1y moveto
  labellength labelang arrow
  grestore
  end
} def % label

/curvedarrow {
  30 dict begin
%
% builds a curved arrow with the center of its base at the current point
%
% assumes the operand stack has the following:
%   1. radius of the curved path
%   2. desired width of the base
%   3. desired length (negative means clockwise pointing)
%
% operation                   operand stack after
% initial                     % rad wid len
  /len exch def               % rad wid
  /wid exch def               % rad
  /rad exch def               %
  /maxincs 600 def
  /rad2deg 57.2957795 def     %
  len rad div                 % (angle in radians)
  rad2deg mul abs             % angle in degrees
  /ang exch def               %
  /abslen len abs def
  /sign len abslen eq def     % "sign" is a boolean - true if positive
  /inc 600 def                % max dpi (for HP4)
  /inc inc abslen mul cvi def % number of arc increments to stroke
  /angdelta ang inc div len abslen div mul def

  /widthdelta wid inc div neg def

  /xx rad neg def
  /yy 0 def
  sign {/ang1 0 def /ang2 angdelta def}
       {/ang1 360 def /ang2 360 angdelta add def} ifelse
  /linewidth wid def
  0 0 mt

  /arcpos {xx yy rad ang1 ang2 arc} def
  /arcneg {xx yy rad ang1 ang2 arcn} def
  /arcproc {
    linewidth lw
	np
	sign {arcpos} {arcneg} ifelse
	st
	/ang1 ang1 angdelta add def
	/ang2 ang2 angdelta add def
	/linewidth linewidth widthdelta add def
  } def

  inc {arcproc} repeat
  end
} def

/arcdimen {
  30 dict begin

%
% builds a curved dimension arrow with the center of its arc at the current point
%
% assumes the operand stack has the following:
%
%   0. arowhead position: 0 - counterclockwise end, 1 - clockwise end, 2 - both, 3 - none
%   1. radius
%   2. starting angle
%   3. ending angle (arc is drawn counterclockwise from start to end
%
% operation                   operand stack after
% initial                     % numarr rad sang eang
  /eang exch def              % numarr rad sang
  /sang exch def              % numarr rad
  /rad exch def               % numarr
  /numarr exch def            %

  /left false def
  /right false def
  /any false def
  0 numarr eq { /left true def /any true def } if
  1 numarr eq { /right true def /any true def } if
  2 numarr eq { /left true def /right true def /any true def } if

%  /len 7 def                  % arrowhead length in points
%  /wid 7 def                  % arrowhead width in points
  any {
  /arrwid currentlinewidth 4 mul def
  /arrlen currentlinewidth 7 mul def
  /maxincs 600 def            % max increments to draw the arrowhead
  /rad2deg 57.2957795 def     %
  arrlen rad div              % (angle in radians)
  rad2deg mul                 % angle in degrees
  /ang exch def               % arrowhead angle
  /inc 600 def                % max dpi (for HP4)
  /inc inc arrlen mul cvi def    % number of arc increments to stroke
  /angdelta ang inc div def % angle subtended by increment
  /widthdelta arrwid inc div neg def
  /arcpos {0 0 rad ang1 ang2 arc} def
  /arcneg {0 0 rad ang1 ang2 arcn} def

  left { /eang eang ang sub def
         /ang1 eang def
         /ang2 eang angdelta add def
         /arrlinewidth arrwid def
         0 0 moveto

         gs
         /arcproc {
            arrlinewidth setlinewidth
	    newpath
	    arcpos
	    stroke
	    /ang1 ang1 angdelta add def
	    /ang2 ang2 angdelta add def
	    /arrlinewidth arrlinewidth widthdelta add def
         } def
         inc {arcproc} repeat
         gr
  } if

  right {
          /sang sang ang add def
          /ang1 sang def
          /ang2 sang angdelta sub def
         /arrlinewidth arrwid def
         0 0 moveto

         gs
         /arcproc {
            arrlinewidth setlinewidth
	    newpath
	    arcneg
	    stroke
	    /ang1 ang1 angdelta sub def
	    /ang2 ang2 angdelta sub def
	    /arrlinewidth arrlinewidth widthdelta add def
         } def
         inc {arcproc} repeat
         gr
  } if

  } if

  0 0 moveto newpath
  0 0 rad sang eang arc
  stroke

  gr
  end
} def % arcdimen arrlen arrwid

/arrow {
  30 dict begin
% makes an arrow from a to b and an arrow head at b--a is at the currentpoint
%
% the following need to be in the operand stack:
%
%   length rotation
%
  /arot exch def
  /len exch def
  gsave
  currentpoint translate
  /aw currentlinewidth 4 mul def
  /al currentlinewidth 7 mul def
  /len len al sub def
  0 0 mt
  arot rotate
  np
  0 0 mt
  len 0 rl st
  np
  len aw .5 mul mt
  0 aw neg rl
  al aw .5 mul rl
  cp fill
  0 0 mt
  grestore
  end
} def% arrow

mydict begin

%**** user definitions go here ******************************************************************************
/sf 72 def
sf dup scale

2 1 tr % set origin at lower left corner of ERA
/lw 1 sf div def
lw setlinewidth

1 setlinecap
1 setlinejoin

% front face
gs
0 0   mt 2 0 rl st
0 0.5 mt 2 0 rl st
0 0 mt 0 .5 rl st
2 0 mt 0 .5 rl st

gr

% right face
gs
2 0 tr
0 0 mt
1 1 rl st
1 1 mt
0 0.5 rl st
gr

% top face
gs
0 .5 mt
2 0 rl
1 1 rl
-2 0 rl
cp st
gr

% top sensitive zone
gs
0.2 .6 mt
1.8 0 rl
.8 .8 rl
-1.8 0 rl
cp st
gr


% for labels
/Times-Roman 12 72 div selectfont

gs
.3 1.2 tr
0 0 mt .65 -20 arrow
gs
-.3 .3 tr
0 0    mt (1. top plate) 10 puttext
0 -.2 mt ((sensitive zone)) 10 puttext
gr
gr

gs
-.3 .3 tr
0 0 mt .25 0 arrow
-.1 0 mt (2. outer shell) 5 puttext
gr

gs
2.3 0.3 tr
.75 .25 mt .57 150 arrow
gs
1 .08 tr
-.1 0 mt (3. explosive) 10 puttext
0 -.2 mt ((inside)) 10 puttext
gr
gr

1.5 1    mt 1 90 arrow
1.6 1.95 mt (outward-facing normal) 1 puttext
end         % clear this dictionary
cleartomark % clear all we've done
showpage
%%EOF
%=============================
% END OF SRS *PostScript* FILE
%=============================
