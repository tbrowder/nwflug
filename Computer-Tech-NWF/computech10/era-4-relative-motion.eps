%!PS-Adobe-3.0 EPSF-3.0
%%BoundingBox: 59 165 278 310
%%Creator:       Tom Browder
%%CreationDate:  2010-01-21
%%Title:         ERA Plate Relative Motion [4]
%%+              file: era-relative-motion-4.eps
%%LanguageLevel: 2
[
%
/mydict 300 dict def
mydict begin
% definitions:
/bd {bind def} bind def
/mt {moveto} bind def
/lto {lineto} bind def
/np {newpath} bind def
/cp {closepath} bind def
/rl {rlineto} bind def
/rm {rmoveto} bind def
/tr {translate} bind def
/st {stroke} bind def
/rot {rotate} bind def
/sl {setlinewidth} bind def
/gs {gsave} bind def
/gr {grestore} bind def
/p2i {72 div} bind def           % convert points to inches
/i2p {72 mul} bind def           % convert inches to points
/mm2p {25.4 div 72 mul} bind def % convert millimeters to points
/a2p {60 div 72 mul} bind def    % convert ASI units (60ths of an inch) to points
/ft2pt 1 def % value normally generated by brldraw; default is 1
% various constants:
/lw1 {1.5 setlinewidth} bind def % main line width (in points)
/lw2 {.75 setlinewidth} bind def % dimension and label line width (in points)
/lengthxyz {20} def % nominal length of a coordinate arrow
/textspace {6} def % space between text and any other object
/ticlen {5} def % length of major tic mark on a scale
/ang_width {.4 72 mul} bind def
/ang_diag {ang_width 45 cos div} bind def
/ds 5 def  % space between point to be dimensioned and the 'hash' mark
/dh 20 def % length of has mark to dimension line
/dt 5 def  % extra hash line 'above' hash mark
/xtra ang_diag ang_width sub 45 cos mul def
end % mydict

/puttext { % string location_code [integer: 0-11] (to place--relative to the current point); must have a current and correct font
  30 dict begin
  /code exch def
  /stname exch def
  gsave
  currentpoint translate np
  0 0 mt stname false charpath flattenpath pathbbox
  /ury exch def
  /urx exch def
  /lly exch def
  /llx exch def
  /mx urx llx add .5 mul def
  /my ury lly add .5 mul def

  0 code eq {/ox 0 mx  sub def /oy 0 my  sub def} if %               center of text bounding box positioned at the current point
  1 code eq {/ox 0 llx sub def /oy 0 my  sub def} if %  center of left edge of text bounding box positioned at the current point
  2 code eq {/ox 0 llx sub def /oy 0 lly sub def} if %    lower left corner of text bounding box positioned at the current point
  3 code eq {/ox 0 mx  sub def /oy 0 lly sub def} if % center of lower edge of text bounding box positioned at the current point
  4 code eq {/ox 0 urx sub def /oy 0 lly sub def} if %   lower right corner of text bounding box positioned at the current point
  5 code eq {/ox 0 urx sub def /oy 0 my  sub def} if % center of right edge of text bounding box positioned at the current point
  6 code eq {/ox 0 urx sub def /oy 0 ury sub def} if %   upper right corner of text bounding box positioned at the current point
  7 code eq {/ox 0 mx  sub def /oy 0 ury sub def} if % center of upper edge of text bounding box positioned at the current point
  8 code eq {/ox 0 llx sub def /oy 0 ury sub def} if %    upper left corner of text bounding box positioned at the current point

  9 code eq {/ox 0 llx sub def /oy 0         def} if % on base line (y of current point), left-justified on current point
 10 code eq {/ox 0 mx  sub def /oy 0         def} if % on base line (y of current point), centered horizontally
 11 code eq {/ox 0 urx sub def /oy 0         def} if % on base line (y of current point), right-justified on current point

  ox oy translate

  gsave
  % 0 setgray
  np 0 0 mt stname show
  grestore

%for debug
%  gsave
%  [3] 0 setdash
%  .1 setlinewidth np
%  llx lly mt urx lly lineto urx ury lineto llx ury lineto closepath stroke
%  grestore

  grestore
  end
} def % puttext

/label { % the stack contains: (label text) p1x p1y p2x p2y % first to last
  30 dict begin
  /p2y exch def
  /p2x exch def
  /p1y exch def
  /p1x exch def
  /labeltext exch def

  /deltax p2x p1x sub def
  /deltay p2y p1y sub def
  /labellength deltax deltax mul deltay deltay mul add sqrt def
  /labelang p2y p1y sub p2x p1x sub atan def

  gsave
  lw2
  p1x p1y moveto
  deltax abs deltax eq {-3 0 rm labeltext 5 puttext}{3 0 rm labeltext 1 puttext} ifelse
  p1x p1y moveto
  labellength labelang arrow
  grestore
  end
} def % label

/curvedarrow {
  30 dict begin
%
% builds a curved arrow with the center of its base at the current point
%
% assumes the operand stack has the following:
%   1. radius of the curved path
%   2. desired width of the base
%   3. desired length (negative means clockwise pointing)
%
% operation                   operand stack after
% initial                     % rad wid len
  /len exch def               % rad wid
  /wid exch def               % rad
  /rad exch def               %
  /maxincs 600 def
  /rad2deg 57.2957795 def     %
  len rad div                 % (angle in radians)
  rad2deg mul abs             % angle in degrees
  /ang exch def               %
  /abslen len abs def
  /sign len abslen eq def     % "sign" is a boolean - true if positive
  /inc 600 def                % max dpi (for HP4)
  /inc inc abslen mul cvi def % number of arc increments to stroke
  /angdelta ang inc div len abslen div mul def

  /widthdelta wid inc div neg def

  /xx rad neg def
  /yy 0 def
  sign {/ang1 0 def /ang2 angdelta def}
       {/ang1 360 def /ang2 360 angdelta add def} ifelse
  /linewidth wid def
  0 0 mt

  /arcpos {xx yy rad ang1 ang2 arc} def
  /arcneg {xx yy rad ang1 ang2 arcn} def
  /arcproc {
    linewidth lw
	np
	sign {arcpos} {arcneg} ifelse
	st
	/ang1 ang1 angdelta add def
	/ang2 ang2 angdelta add def
	/linewidth linewidth widthdelta add def
  } def

  inc {arcproc} repeat
  end
} def

/arcdimen {
  30 dict begin

%
% builds a curved dimension arrow with the center of its arc at the current point
%
% assumes the operand stack has the following:
%
%   0. arowhead position: 0 - counterclockwise end, 1 - clockwise end, 2 - both, 3 - none
%   1. radius
%   2. starting angle
%   3. ending angle (arc is drawn counterclockwise from start to end
%
% operation                   operand stack after
% initial                     % numarr rad sang eang
  /eang exch def              % numarr rad sang
  /sang exch def              % numarr rad
  /rad exch def               % numarr
  /numarr exch def            %

  /left false def
  /right false def
  /any false def
  0 numarr eq { /left true def /any true def } if
  1 numarr eq { /right true def /any true def } if
  2 numarr eq { /left true def /right true def /any true def } if

%  /len 7 def                  % arrowhead length in points
%  /wid 7 def                  % arrowhead width in points
  any {
  /arrwid currentlinewidth 4 mul def
  /arrlen currentlinewidth 7 mul def
  /maxincs 600 def            % max increments to draw the arrowhead
  /rad2deg 57.2957795 def     %
  arrlen rad div              % (angle in radians)
  rad2deg mul                 % angle in degrees
  /ang exch def               % arrowhead angle
  /inc 600 def                % max dpi (for HP4)
  /inc inc arrlen mul cvi def    % number of arc increments to stroke
  /angdelta ang inc div def % angle subtended by increment
  /widthdelta arrwid inc div neg def
  /arcpos {0 0 rad ang1 ang2 arc} def
  /arcneg {0 0 rad ang1 ang2 arcn} def

  left { /eang eang ang sub def
         /ang1 eang def
         /ang2 eang angdelta add def
         /arrlinewidth arrwid def
         0 0 moveto

         gs
         /arcproc {
            arrlinewidth setlinewidth
	    newpath
	    arcpos
	    stroke
	    /ang1 ang1 angdelta add def
	    /ang2 ang2 angdelta add def
	    /arrlinewidth arrlinewidth widthdelta add def
         } def
         inc {arcproc} repeat
         gr
  } if

  right {
          /sang sang ang add def
          /ang1 sang def
          /ang2 sang angdelta sub def
         /arrlinewidth arrwid def
         0 0 moveto

         gs
         /arcproc {
            arrlinewidth setlinewidth
	    newpath
	    arcneg
	    stroke
	    /ang1 ang1 angdelta sub def
	    /ang2 ang2 angdelta sub def
	    /arrlinewidth arrlinewidth widthdelta add def
         } def
         inc {arcproc} repeat
         gr
  } if

  } if

  0 0 moveto newpath
  0 0 rad sang eang arc
  stroke

  gr
  end
} def % arcdimen arrlen arrwid

/arrow {
  30 dict begin
% makes an arrow from a to b and an arrow head at b--a is at the currentpoint
%
% the following need to be in the operand stack:
%
%   length rotation
%
  /arot exch def
  /len exch def
  gsave
  currentpoint translate
  /aw currentlinewidth 4 mul def
  /al currentlinewidth 7 mul def
  /len len al sub def
  0 0 mt
  arot rotate
  np
  0 0 mt
  len 0 rl st
  np
  len aw .5 mul mt
  0 aw neg rl
  al aw .5 mul rl
  cp fill
  0 0 mt
  grestore
  end
} def% arrow


% create a vector named P with an small letter subscript at the current point
/PV { % stack (single subscript character)
    20 dict begin
    /str exch def
    gs
    currentpoint tr
    % kludge back to "normal" scale
    1 72 div dup scale

    /Times-Bold 12 selectfont
    0 0 mt (P) show

    % the subscript
    /Times-Bold 7.5 selectfont
    -1 -3 rm str show

    gr
    end
}def

mydict begin

%**** user definitions go here ******************************************************************************
/rot  90 def % rotation angle to get plates oriented vertically
/rot2 -20 def % rotation angle to lay plate back from vertical

/rot rot rot2 add def
/rot3 rot neg def

/sf 72 def
sf dup scale

4 2 tr     % set origin at lower left corner of ERA
rot rotate % set fall back angle
/lw 1 sf div def
lw setlinewidth

%1 setlinecap
%1 setlinejoin

% for labels
/Times-Roman 12 72 div selectfont

% outer plate (new position)
gs
0 1.0 mt
2 0 rl
0 1.1 mt
2 0 rl
st
gr

% jet path
gs
1 .25 tr % center of figure
rot3 rotate
gs
[3 72 div] 0 setdash
.5 72 div setlinewidth
-0.88 0 mt 0.5 0 rl st
gr
%-1.75 0 mt (jet path) 5 puttext
%-1.7  0 mt .79 0 arrow
-2.75 0 mt (jet path) 5 puttext
-2.7  0 mt 1.79 0 arrow
gr

% dashed lines on each end
gs
[3 72 div] 0 setdash
.1 72 div setlinewidth

% left end
0 0.9 mt
0 0.3 rl
% right end
2 0.9 mt
0 0.3 rl st
gr

%% test subscripts
%gs
%-70 rotate
%2.0 2 mt (a) PV
%2.2 2 mt (j) PV
%2.4 2 mt (f) PV
%gr

% some call outs
% outer plate
%1.0 1.2  mt .5 90 arrow
1.0 1.2  mt 1.0 90 arrow

% resolve plate motion into components parallel to plate
% and parallel to jet
/hyp 1 20 cos div def
/y hyp 20 sin mul def
% face component
gs
1 1.2 tr
-90 rotate
0 0 mt y 90 arrow
gr
% label
% jet component
1.0 1.2 mt hyp 110 arrow
% label
gs
gr

/dw .5 72 div def
% plate motion parallel to its face
gs
[3 72 div] 0 setdash
dw setlinewidth
1 1.2 tr
y 0 mt
0 1 lto st
gr
% plate motion parallel to jet path
gs
[3 72 div] 0 setdash
dw setlinewidth
1 1.2 tr
0 1 tr
90 rotate
0 0 mt 0 y lto st
gr

% more callouts for the plate motion vectors
gs
1 1.2 tr
0 1 tr
rot3 rotate
-4 72 div 4 72 div  mt () PV
1 .1 mt (f) PV
-.3 -.3 mt (j) PV
gr


% end, clear, and show
end         % clear this dictionary
cleartomark % clear all we've done
showpage
%%EOF
%=============================
% END OF SRS *PostScript* FILE
%=============================
